# attendance_summary.py
import pandas as pd

# ===============================
# ① 勤怠データの読み込み
# ===============================
input_file = "sample_data/attendance_2024_10.xlsx"
df = pd.read_excel(input_file)

print("📘 勤怠データを読み込みました。")
print(df.head())  # データ確認

# read_excel は1シート前提（複数シートがある場合は sheet_name= を指定）。
# 読み込み直後の head() 出力は データ型・欠損の早期発見 に有効。
# 例：勤務時間 が文字列として入っていないか、日付 が日付型になっているか等。

# ===============================
# ② 集計処理
# ===============================

# 勤務日数：勤務時間が0より大きい日数をカウント
work_days = df[df["勤務時間"] > 0].groupby("社員名")["日付"].count().rename("勤務日数")

# 「勤務時間 > 0」を“出勤”とみなす（0＝有給や欠勤）。
# その行数を 社員名 ごとにカウント → 勤務日数。

# カスタム余地
# 「0.25や0.5は早退・遅刻扱いだから勤務日数に含める/含めない」などの 社内ルール に合わせて閾値を変える：
# work_days = df[df["勤務時間"] >= 0.25].groupby("社員名")["日付"].count().rename("勤務日数")

# 残業時間：勤務時間が8時間を超える分を合計
df["残業時間"] = df["勤務時間"].apply(lambda x: x - 8 if x > 8 else 0)
overtime = df.groupby("社員名")["残業時間"].sum().rename("残業時間")

# 1日あたり 基準8時間 を超えた「超過分」だけを切り出し、社員別に合計。
# lambda（ラムダ式）とは？
# 「一時的に使う、名前のない関数」 のことです。
# 英語では anonymous function（無名関数） と呼ばれます。

# ①	df["勤務時間"] の各値（例：8.0, 9.5, 7.5 ...）を x に渡す
# ②	x が8より大きければ「x−8」、そうでなければ「0」を返す
# ③	その結果を新しい列「残業時間」に代入

# 有給日数：「休暇区分」が「有給」の件数をカウント
paid_leave = (
    df[df["休暇区分"] == "有給"].groupby("社員名")["日付"].count().rename("有給日数")
)

# 休暇区分 が「有給」の行数を社員別にカウント。

# ===============================
# ③ 集計結果を結合
# ===============================
summary = pd.concat([work_days, overtime, paid_leave], axis=1).fillna(0)
summary = summary.reset_index()

# 数値列を小数第1位で丸める（見やすくするため）
summary["残業時間"] = summary["残業時間"].round(1)

# axis=1 は 列方向（横方向） に結合する指定。
# index（ここでは社員名）が同じなら、自動的に横並びに結合 されます。
# 社員によっては“有給が0件”の列が欠けるため、fillna(0) で欠損を0に。
# reset_index() で 社員名 を列に戻して表形式に整形。
# 👉index は表の“左端”にあるが、通常のデータ列ではないため、Excel出力すると「ラベル扱い」になってしまいます。
# 小数丸めは見栄え目的。（仕様で単位/丸めを決めると良い）

print("\n✅ 集計結果プレビュー：")
print(summary)

# ===============================
# ④ Excelファイルに出力
# ===============================
output_file = "attendance_summary.xlsx"
summary.to_excel(output_file, index=False)

# index=Falseを入れることで、余分なインデックス列番号が出力されないようにする。

print(f"\n🎯 集計完了！結果を {output_file} に出力しました。")
